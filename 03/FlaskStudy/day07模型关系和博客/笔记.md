主要理解多张数据库表的关系。

明确：一个项目肯定会有多张表，确定表与表之间的关系最重要。
在开始项目前必须要确定表与表的关系

单独一张表： User 是不行的。user要与其他的建立联系。

以student和班级clazz为例：
一个班级是有多名学生的



> 查询python01班级的学生

```sql
select * from student where 班级=（select id from clazz where 班级名=‘python01’）
或者
select * from student inner join clazz on student.班级=clazz.id where clazz.班级名='python01' 
```

> 查询xiaowang所在的班级名

```sql
select 班级名 from clazz where id= (select 班级 from student where name='xiaowang')
或者
select 班级名 from student inner join clazz on student.班级=clazz.id where name='xiaowang'
```

# 1对多

> 在flask的框架中如何体现1对多的模型关系？
>
> 就是通过外键ForignKey和relationship体现。ForignKey是给映射关系说的，relationship是给模板使用的。

### user表 

`虚拟字段名 = db.relationship('外表名称', backref='反向引用名称')`

`articles = db.relationship('Article', backref='user')`

```python
user.articles	# 获取所有文章

article.user    # 获取用户
```



```python
# 通过 ORM 映射建立表  类 ----》 表
'''
在 app.py中导入这两个类
python app.py db init       产生一个文件夹migrations 只需要init一次
python app.py db migrate    自动产生了一个版本文件,添加数据表Model就使用一次
python app.py db upgrade    新建(更新数据表)
python app.py db downgrade  降级(回到上一个数据表)
注意: 上面的db是在app.py中添加进去的
    # 将migrate命令添加到migrate
    manager.add_command('db', MigrateCommand)   # 参数是名字和命令
'''
from exts import db
from datetime import datetime


# create table user(id int primarykey auto_increment,username varchar(20) not null,..)
class User(db.Model):
    '''
    用户表
    不用在__init__中写,在类全局写
    列: db.Column(类型，约束)  映射表中的列
    类型：
    db.Integer      int
    db.String(15)   varchar(15)
    db.Datetime     datetime
    db.Boolean
    '''
    id        = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username  = db.Column(db.String(256), nullable=False, comment="用户名")
    password  = db.Column(db.String(256), nullable=False, comment="密码")
    phone     = db.Column(db.String(20), unique=True, nullable=True,comment="手机")
    email     = db.Column(db.String(50), comment="email")
    icon      = db.Column(db.String(256), comment="头像")
    realname  = db.Column(db.String(50), comment="真实姓名") # comment是字段说明,自己试出来的
    isdelete  = db.Column(db.Boolean, default=False, comment="软删除")
    rdatetime = db.Column(db.DateTime, default=datetime.now, comment="注册时间")
	
    # 这个写在主表和辅表都可以,不过只能写一个
    # 增加一个字段表示文章,不会在数据库中出现,是在模板中 关联表反向引用
    # user.articles 可以获取相关文章列表
    # backref='user' 可以使用 article.user 反向获取用户
    articles = db.relationship('Article', backref='user')

    def __str__(self):
        return self.username

```

### article表

```python
from exts import db
from datetime import datetime


class Article(db.Model):
    '''
    文章表
    db.Text: 长文本
    '''
    id          = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title       = db.Column(db.String(50), nullable=False, comment="标题")
    content     = db.Column(db.Text, nullable=False, comment="内容")
    pdatetime   = db.Column(db.DateTime, default=datetime.now, comment="发布时间")
    read_number = db.Column(db.Integer, default=0, comment="阅读数")
    collect_number = db.Column(db.Integer, default=0, comment="收藏数")
    fav_number  = db.Column(db.Integer, default=0, comment="喜欢数")
    user_id     = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False,comment="用户外键")
    isdelete    = db.Column(db.Boolean, default=False, comment="软删除")

    def __str__(self):
        return self.title
```

### html

> all

```jinja2
{% for article in articles %}
    <div id="container">
        <h1>{{ article.title }}</h1>
        <p>作者: {{ article.user.username }}</p>    <!-- User表中: articles = db.relationship('Article', backref='user') -->
        <p>时间: {{ article.pdatetime }}</p>
        <p>{{ article.content }}</p>
    </div>
{% endfor %}
```

> author_all

```jinja2
                <!-- 这样是因为 UserModel中的 articles = db.relationship('Article', backref='user') -->
{% for article in user.articles %}
    <div id="container">
        <h1>{{ article.title }}</h1>
        <p>作者: {{ article.user.username }}</p>    <!-- User表中: articles = db.relationship('Article', backref='user') 根据文章找作者 -->
        <p>时间: {{ article.pdatetime }}</p>
        <p>{{ article.content }}</p>
    </div>
{% endfor %}
```



# 多对多

一个学生可以选择多门课程，反过来一门课程还可以让多个学生选择

```python
tags = db.Table('tags',
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id')),
    db.Column('page_id', db.Integer, db.ForeignKey('page.id'))
)

class Page(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    tags = db.relationship('Tag', secondary=tags,
        backref=db.backref('pages', lazy='dynamic'))

class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20),nullable=False)
```

或者

```python
class Page(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    tags = db.relationship('Tag', secondary='Page_tag',
        backref='pages')

class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20),nullable=False)
    
class Page_tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'))
    db.Column('page_id', db.Integer, db.ForeignKey('page.id'))
```

